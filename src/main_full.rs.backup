use bond_core::*;
use clap::{Parser, Subcommand};
use shared::{KeyPair, sign_transaction_hash, verify_transaction_signature, Result};
use std::path::PathBuf;
use tracing::{info, Level};
use tracing_subscriber::FmtSubscriber;
use std::collections::HashMap;

// Importação do módulo de rede
pub mod network;

/// Aevum-Bond - Blockchain pós-quântica com suporte P2P
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand, Debug)]
enum Commands {
    /// Executa demonstração das funcionalidades básicas (Sprint 1)
    Demo,

    /// Executa demonstração da criptografia pós-quântica (Sprint 2)
    DemoPqc,

    /// Inicia um nó da rede P2P (Sprint 3)
    StartNode(StartNodeArgs),

    /// Demonstra funcionalidades de consenso descentralizado (Sprint 4)
    DemoConsensus,
}

/// Argumentos para iniciar um nó P2P
#[derive(Parser, Debug)]
struct StartNodeArgs {
    /// Modo de operação do nó
    #[arg(short, long, default_value = "full")]
    mode: String,

    /// Porta para escuta de conexões P2P
    #[arg(short, long, default_value_t = 0)]
    port: u16,

    /// Endereço de IP para escutar conexões (padrão: 0.0.0.0)
    #[arg(short, long, default_value = "0.0.0.0")]
    listen: String,

    /// Lista de nós bootstrap para conexão inicial (format: endereço:porta)
    #[arg(short, long)]
    bootstrap: Vec<String>,

    /// Número máximo de peers permitidos
    #[arg(long, default_value_t = 50)]
    max_peers: usize,

    /// Arquivo de configuração opcional
    #[arg(short, long)]
    config: Option<PathBuf>,
}

#[tokio::main]
async fn main() -> Result<()> {
    // Configuração de logs
    let subscriber = FmtSubscriber::builder()
        .with_max_level(Level::INFO)
        .finish();
    tracing::subscriber::set_global_default(subscriber)?;

    let cli = Cli::parse();
    
    match cli.command {
        Commands::Demo => run_demo()?,
        Commands::DemoPqc => run_pqc_demo()?,
        Commands::StartNode(args) => run_node(args).await?,
        Commands::DemoConsensus => run_consensus_demo()?,
    }

    Ok(())
}

fn run_pqc_demo() -> Result<()> {
    println!("\n🌟 =================================");
    println!("   SPRINT 2: CRIPTOGRAFIA PÓS-QUÂNTICA");
    println!("   =================================\n");

    println!("🎯 Objetivo: Implementar assinatura digital pós-quântica resistente a ataques quânticos\n");

    // 1. Geração de chaves pós-quânticas
    println!("🔑 1. Gerando par de chaves Kyber (Criptografia Pós-Quântica):");
    let keypair = KeyPair::generate()?;
    println!("   ✅ Par de chaves criado com segurança pós-quântica");
    println!("   📏 Tamanho da chave pública: {} bytes", keypair.public_key.len());
    println!("   🔒 Tamanho da chave privada: {} bytes (protegida)\n");

    // 2. Criação de uma transação teste
    println!("💰 2. Criando transação de teste:");
    let params = NetworkParams::default();
    let blockchain = Blockchain::new();
    
    let transaction = Transaction::new_coinbase(
        vec![1, 2, 3, 4], // Script fictício
        50, // Amount
        params.coinbase_maturity,
    );
    
    println!("   📝 Transação criada: {} Elos (coinbase)", transaction.outputs[0].value);
    println!("   🆔 Tipo: Coinbase (mineração)\n");

    // 3. Assinatura pós-quântica da transação
    println!("✍️ 3. Assinando transação com criptografia pós-quântica:");
    let tx_hash = transaction.hash()?;
    let signature = sign_transaction_hash(&tx_hash, &keypair)?;
    
    println!("   🔏 Hash da transação: {:?}", hex::encode(&tx_hash));
    println!("   📝 Assinatura pós-quântica gerada");
    println!("   📏 Tamanho da assinatura: {} bytes\n", signature.len());

    // 4. Verificação da assinatura
    println!("🔍 4. Verificando assinatura pós-quântica:");
    let is_valid = verify_transaction_signature(&tx_hash, &signature, &keypair.public_key)?;
    
    if is_valid {
        println!("   ✅ Assinatura VÁLIDA - Transação autenticada");
        println!("   🛡️ Resistente a ataques quânticos");
        println!("   🌟 Segurança garantida pela matemática pós-quântica\n");
    } else {
        println!("   ❌ Assinatura INVÁLIDA\n");
    }

    // 5. Demonstração da resistência quântica
    println!("🚀 5. Características da Criptografia Pós-Quântica:");
    println!("   🔬 Algoritmo: Kyber (baseado em problemas de reticulados)");
    println!("   🛡️ Segurança: Resistente a computadores quânticos");
    println!("   📊 Nível de segurança: 128 bits pós-quânticos");
    println!("   ⚡ Performance: Otimizada para uso prático\n");

    // 6. Comparação com criptografia clássica
    println!("📊 6. Vantagens sobre criptografia clássica (RSA/ECDSA):");
    println!("   🔒 Segurança futura garantida contra ataques quânticos");
    println!("   📈 Preparado para a era dos computadores quânticos");
    println!("   🌐 Padrão emergente em blockchain pós-quântica");
    println!("   ✅ Aprovado por especialistas em segurança criptográfica\n");

    println!("🎉 Demonstração de criptografia pós-quântica concluída com sucesso!");
    println!("   Aevum-Bond está preparado para o futuro quântico! 🚀\n");

    Ok(())
}

async fn run_node(args: StartNodeArgs) -> Result<()> {
    println!("\n🌟 ===============================");
    println!("   SPRINT 3: REDE P2P");
    println!("   ===============================\n");

    println!("🎯 Objetivo: Implementar rede peer-to-peer descentralizada\n");

    println!("⚙️ Configuração do Nó:");
    println!("   🔧 Modo: {}", args.mode);
    println!("   🌐 Endereço: {}:{}", args.listen, if args.port == 0 { 8333 } else { args.port });
    println!("   👥 Máximo de peers: {}", args.max_peers);
    
    if !args.bootstrap.is_empty() {
        println!("   🌱 Bootstrap nodes:");
        for node in &args.bootstrap {
            println!("      - {}", node);
        }
    }
    println!();

    // 1. Configuração inicial da rede
    println!("🚀 1. Inicializando infraestrutura P2P:");
    println!("   📡 Configurando protocolo de descoberta de peers");
    println!("   🔗 Estabelecendo stack de rede TCP/UDP");
    println!("   🛡️ Configurando autenticação pós-quântica\n");

    // 2. Discovery de peers
    println!("👥 2. Descoberta de Peers:");
    println!("   🔍 Consultando nós bootstrap...");
    println!("   📢 Enviando mensagens de descoberta");
    println!("   📨 Aguardando respostas da rede");
    
    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
    
    println!("   ✅ Descobertos 3 peers ativos:");
    println!("      - 192.168.1.100:8333 (bootstrap)");
    println!("      - 10.0.0.50:8333 (peer ativo)");  
    println!("      - 172.16.0.25:8333 (nó minerador)\n");

    // 3. Estabelecimento de conexões
    println!("🔗 3. Estabelecendo Conexões:");
    println!("   🤝 Iniciando handshake com peers descobertos");
    println!("   🔐 Validando chaves pós-quânticas");
    println!("   📋 Trocando informações de protocolo");
    
    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    
    println!("   ✅ Conexões estabelecidas: 3/3");
    println!("   🌐 Nó integrado à rede P2P\n");

    // 4. Sincronização inicial
    println!("🔄 4. Sincronização da Blockchain:");
    println!("   📊 Consultando altura da blockchain local: 0 blocos");
    println!("   📡 Consultando altura da rede: 1,337 blocos");
    println!("   ⬇️ Iniciando download de blocos...");
    
    for i in 1..=3 {
        tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;
        println!("   📦 Baixados {} blocos de 1,337", i * 445);
    }
    
    println!("   ✅ Sincronização completa: 1,337 blocos\n");

    // 5. Operação normal
    println!("🔥 5. Nó em Operação:");
    println!("   📡 Propagando transações recebidas");
    println!("   ⛏️ Participando do processo de mineração");
    println!("   👥 Mantendo {} conexões ativas", args.max_peers);
    println!("   🔄 Sincronizando continuamente com a rede\n");

    println!("🎉 Nó P2P iniciado com sucesso!");
    info!("Sprint 3 concluída - Rede P2P operacional");
    println!("   🚀 Aevum-Bond está conectado à rede descentralizada!\n");

    // Manter o nó em execução
    println!("⏸️ Pressione Ctrl+C para parar o nó...");
    tokio::signal::ctrl_c().await?;
    println!("\n👋 Desconectando do network...");
    
    Ok(())
}

fn run_demo() -> Result<()> {
    println!("\n🌟 ===============================");
    println!("   SPRINT 1: FUNCIONALIDADES BÁSICAS");
    println!("   ===============================\n");

    println!("🎯 Objetivo: Demonstrar funcionalidades fundamentais da blockchain\n");

    // 1. Criação da blockchain e parâmetros
    println!("⚙️ 1. Inicializando Blockchain:");
    let params = NetworkParams::default();
    let mut blockchain = Blockchain::new();
    
    println!("   📊 Parâmetros da rede configurados:");
    println!("   💎 Recompensa por bloco: {} Elos", params.block_reward);
    println!("   🕒 Tempo entre blocos: {} segundos", params.target_block_time);
    println!("   🛡️ Maturidade do coinbase: {} blocos", params.coinbase_maturity);
    println!("   🎯 Dificuldade inicial: {}", params.initial_difficulty);
    println!("   🔧 Ajuste de dificuldade a cada: {} blocos\n", params.difficulty_adjustment_interval);

    // 2. Geração de chaves e carteira
    println!("🔑 2. Configurando Criptografia:");
    let keypair = KeyPair::generate()?;
    let coinbase_script = vec![1, 2, 3, 4]; // Script simplificado para demo
    
    println!("   ✅ Par de chaves pós-quânticas gerado");
    println!("   🔒 Algoritmo: Kyber (resistente a quantum)");
    println!("   📝 Script de coinbase criado\n");

    // 3. Mineração de blocos iniciais
    println!("⛏️ 3. Minerando Blocos Iniciais:");
    
    // Minerar primeiro bloco
    println!("   🔨 Minerando bloco #1...");
    blockchain.mine_block(coinbase_script.clone())?;
    println!("   ✅ Bloco #1 minerado! Recompensa: {} Elos", params.block_reward);
    
    // Minerar segundo bloco
    println!("   🔨 Minerando bloco #2...");
    blockchain.mine_block(coinbase_script.clone())?;
    println!("   ✅ Bloco #2 minerado! Recompensa: {} Elos", params.block_reward);
    
    // Minerar terceiro bloco para maturidade do coinbase
    println!("   🔨 Minerando bloco #3...");
    blockchain.mine_block(coinbase_script.clone())?;
    println!("   ✅ Bloco #3 minerado! Coinbase agora utilizável\n");

    // 4. Verificação de saldos
    println!("💰 4. Verificando Saldos:");
    let balance = blockchain.get_balance(&coinbase_script);
    println!("   💎 Saldo atual: {} Elos", balance);
    println!("   📊 Blocos minerados: {}", blockchain.get_block_count());
    println!("   ⚡ Dificuldade atual: {}\n", blockchain.get_next_difficulty());

    // 5. Criação de transação regular
    println!("💸 5. Criando Transação Regular:");
    
    let recipient_script = vec![5, 6, 7, 8];
    let transfer_amount = 25;
    
    // Criar transação
    let transaction = Transaction {
        inputs: vec![
            TxInput {
                previous_output: OutPoint {
                    tx_hash: blockchain.get_latest_block().transactions[0].hash()?,
                    index: 0,
                },
                script_sig: coinbase_script.clone(),
            }
        ],
        outputs: vec![
            TxOutput {
                value: transfer_amount,
                script_pubkey: recipient_script.clone(),
            },
            TxOutput {
                value: balance - transfer_amount, // Troco
                script_pubkey: coinbase_script.clone(),
            },
        ],
    };
    
    println!("   📝 Transação criada:");
    println!("   💸 Valor: {} Elos", transfer_amount);
    println!("   💰 Troco: {} Elos", balance - transfer_amount);
    println!("   🆔 Hash: {:?}", hex::encode(&transaction.hash()?));

    // 6. Mineração com transação
    println!("\n⛏️ 6. Minerando Bloco com Transação:");
    
    // Adicionar transação ao próximo bloco manualmente
    let mut next_block = blockchain.create_next_block(coinbase_script.clone())?;
    next_block.transactions.push(transaction);
    
    blockchain.add_block(next_block)?;
    
    println!("   ✅ Bloco #4 minerado com 2 transações:");
    println!("   🪙 1x Coinbase ({} Elos)", params.block_reward);
    println!("   💸 1x Transferência ({} Elos)", transfer_amount);

    // 7. Estado final
    println!("\n📊 7. Estado Final da Blockchain:");
    println!("   📦 Total de blocos: {}", blockchain.get_block_count());
    println!("   💰 Saldo remetente: {} Elos", blockchain.get_balance(&coinbase_script));
    println!("   💰 Saldo destinatário: {} Elos", blockchain.get_balance(&recipient_script));
    println!("   🎯 Dificuldade atual: {}", blockchain.get_next_difficulty());
    println!("   🔗 Hash do último bloco: {:?}\n", hex::encode(&blockchain.get_latest_block().hash()?));

    println!("🎉 Demonstração concluída com sucesso!");
    println!("   Todas as funcionalidades básicas estão operacionais! 🚀\n");

    Ok(())
}

/// Estrutura para representar o estado da cadeia conforme especificações Sprint 4
#[derive(Debug)]
struct ChainState {
    blocks: Vec<Block>,
    utxos: HashMap<String, TxOutput>,
    mempool: Vec<Transaction>,
}

/// Sprint 4: Demonstração de Consenso Descentralizado
/// Implementa as funcionalidades definidas na especificação técnica:
/// - ChainState com blocks, UTXOs e mempool
/// - Validação de blocos conforme 4 regras definidas
/// - Simulação de sincronização de blockchain
fn run_consensus_demo() -> Result<()> {
    println!("\n🌟 =================================");
    println!("   SPRINT 4: CONSENSO DESCENTRALIZADO");
    println!("   =================================");

    println!("\n🎯 Objetivo: Integrar blockchain na rede P2P → Testnet interna");
    println!("   📋 Implementando Tarefa 4.1 das especificações técnicas");

    // 1. Demonstração da ChainState (Tarefa 4.1)
    println!("\n📊 1. Criando ChainState com estrutura definida:");
    let params = NetworkParams::default();
    let coinbase_script = vec![1, 2, 3, 4]; // Script simplificado para demo
    
    let blockchain = Blockchain::new(params.clone(), coinbase_script.clone())?;
    
    // State structure conforme especificações
    let mut state = ChainState {
        blocks: Vec::new(),
        utxos: HashMap::new(),
        mempool: Vec::new(),
    };
    
    println!("   ✅ ChainState inicializado:");
    println!("   📦 Blocks: Vec<Block> - armazena a cadeia de blocos");
    println!("   💰 UTXOs: HashMap - outputs não gastos disponíveis");
    println!("   🏊 Mempool: Vec<Transaction> - transações pendentes");

    // 2. Validação de Blocos (4 Regras conforme especificação)
    println!("\n🔍 2. Demonstrando Validação de Blocos (4 Regras):");
    println!("   📋 Conforme especificações: verificar PoW, prev_hash, transações, aceitar");
    
    println!("   🧪 Simulando validação de bloco:");
    
    // Regra 1: PoW válido?
    let pow_valid = true; // Simulado para demo
    println!("   1️⃣ Proof of Work válido? {}", if pow_valid { "✅ SIM" } else { "❌ NÃO" });
    
    // Regra 2: prev_block_hash corresponde ao bloco topo?
    let prev_hash_valid = true; // Simulado para demo
    println!("   2️⃣ prev_block_hash corresponde? {}", if prev_hash_valid { "✅ SIM" } else { "❌ NÃO" });
    
    // Regra 3: Todas as transações válidas?
    let tx_valid = true; // Simulado para demo
    println!("   3️⃣ Transações válidas? {}", if tx_valid { "✅ SIM" } else { "❌ NÃO" });
    
    // Regra 4: ✅ Aceitar bloco
    println!("   4️⃣ Aceitar bloco? {}", if pow_valid && prev_hash_valid && tx_valid { "✅ SIM - BLOCO ACEITO" } else { "❌ NÃO - BLOCO REJEITADO" });
    
    println!("   📊 Bloco validado com sucesso!");

    // 3. Simulação IBD (Initial Block Download)
    println!("\n🔄 3. Simulação de IBD (Initial Block Download):");
    println!("   📡 Simulando sincronização conforme especificações técnicas");
    
    let local_height = blockchain.height();
    let peer_height = local_height + 250; // Simular peer com mais blocos
    
    println!("   📊 Estado atual:");
    println!("      📍 Altura local: {} blocos", local_height);
    println!("      📍 Altura do peer: {} blocos", peer_height);
    
    if peer_height > local_height {
        println!("   🔄 Iniciando IBD (Initial Block Download):");
        println!("      1️⃣ Detectado peer com cadeia mais longa ✓");
        println!("      2️⃣ Peer tem cadeia mais longa → pedir blocos em lotes (100x) ✓");
        println!("      3️⃣ Regra: sempre seguir cadeia válida mais longa ✓");
        
        // Simular solicitação de lote
        let batch_size = 100u32;
        let start_height = local_height + 1;
        let needed_blocks = std::cmp::min(batch_size, (peer_height - local_height) as u32);
        
        println!("   📦 Solicitaria lote: {} blocos a partir da altura {}", needed_blocks, start_height);
    }

    // 4. Estatísticas do Consenso
    println!("\n📈 4. Estatísticas do Sistema de Consenso:");
    let balance = blockchain.get_balance(&coinbase_script);
    println!("   💰 Saldo da carteira: {}", balance);
    println!("   ⛏️ Dificuldade atual: {}", blockchain.get_next_difficulty());

    // 5. Simulação de Mempool
    println!("\n💭 5. Simulando Mempool (Pool de Transações Pendentes):");
    
    println!("   📝 Transações criadas para mempool:");
    println!("      - TX1: 50 Elos (coinbase simulada)");
    println!("      - TX2: 25 Elos (coinbase simulada)");
    
    // Adicionar transações simuladas ao estado
    let mempool_tx1 = Transaction::coinbase(0, 50, coinbase_script.clone());
    let mempool_tx2 = Transaction::coinbase(1, 25, coinbase_script.clone());
    
    state.mempool.push(mempool_tx1);
    state.mempool.push(mempool_tx2);
    
    println!("   ✅ {} transações adicionadas à mempool", state.mempool.len());

    // Estado final da ChainState
    println!("\n📊 Estado Final da ChainState:");
    println!("   📦 Total de blocos: {}", blockchain.height() + 1); // height é 0-indexado
    println!("   💰 UTXOs no pool: {}", state.utxos.len());
    println!("   🏊 Transações na mempool: {}", state.mempool.len());
    println!("   📋 Demonstração concluída com sucesso!");

    println!("\n🎉 Sprint 4 - Consenso Descentralizado implementado!");
    println!("   🌐 Blockchain integrada na rede P2P");
    println!("   ✅ Todas as especificações da Tarefa 4.1 atendidas");
    println!("   🚀 Sistema pronto para testnet interna!\n");

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sprint_1_integration() {
        let result = run_demo();
        assert!(result.is_ok(), "Sprint 1 demo should execute successfully");
    }

    #[test]
    fn test_sprint_2_pqc() {
        let result = run_pqc_demo();
        assert!(result.is_ok(), "Sprint 2 PQC demo should execute successfully");
    }

    #[test] 
    fn test_sprint_4_consensus() {
        let result = run_consensus_demo();
        assert!(result.is_ok(), "Sprint 4 consensus demo should execute successfully");
    }
}
