//! Sprint 3: P2P Networking Module
//! Transitioning from mock to real libp2p implementation

use bond_core::{Block, Blockchain, Transaction};
use futures::StreamExt;
use libp2p::{
    Multiaddr, PeerId, Swarm, SwarmBuilder, gossipsub, identify, kad, mdns, noise,
    request_response::{self, ProtocolSupport},
    swarm::{NetworkBehaviour, SwarmEvent},
    tcp, yamux,
};
use libp2p_swarm_derive::NetworkBehaviour;
use serde::{Deserialize, Serialize};
use shared::{BlockchainError, Result};
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};
use std::time::Duration;
use tokio::select;
use tracing::{debug, error, info, warn};

/// P2P Network Configuration
#[derive(Debug, Clone)]
pub struct P2PConfig {
    pub listen_addr: String,
    pub port: u16,
    pub bootstrap_nodes: Vec<String>,
    pub max_peers: usize,
    pub connection_timeout: Duration,
    pub enable_mdns: bool,
    pub enable_kad_dht: bool,
}

impl Default for P2PConfig {
    fn default() -> Self {
        Self {
            listen_addr: "0.0.0.0".to_string(),
            port: 0, // Random port by default
            bootstrap_nodes: vec![],
            max_peers: 50,
            connection_timeout: Duration::from_secs(30),
            enable_mdns: true,
            enable_kad_dht: true,
        }
    }
}

/// Protocol for blockchain network communication
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BlockchainProtocol();

/// Simple codec for JSON serialization
#[derive(Debug, Clone)]
pub struct BlockchainCodec();
/// Messages exchanged in the P2P network
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NetworkMessage {
    /// Broadcast a new block to peers
    BlockBroadcast(Block),
    /// Request blocks from a specific height
    BlockRequest { from_height: u64 },
    /// Response with blocks
    BlockResponse(Vec<Block>),
    /// Broadcast a transaction to the mempool
    TransactionBroadcast(Transaction),
    /// Ping message for peer discovery
    Ping { node_id: String, timestamp: u64 },
    /// Pong response to ping
    Pong { node_id: String, timestamp: u64 },
    /// Blockchain sync request
    SyncRequest { chain_height: u64 },
    /// Blockchain sync response
    SyncResponse { blocks: Vec<Block>, height: u64 },
}

/// Gossipsub topic for blockchain messages
pub const BLOCKCHAIN_TOPIC: &str = "aevum-bond-blockchain";
pub const TRANSACTION_TOPIC: &str = "aevum-bond-transactions";

/// P2P Network Behavior - Simplified version
#[derive(NetworkBehaviour)]
pub struct P2PBehaviour {
    /// Gossipsub for broadcasting blocks and transactions
    pub gossipsub: gossipsub::Behaviour,
    /// mDNS for local peer discovery
    pub mdns: mdns::tokio::Behaviour,
    /// Identify protocol for peer identification
    pub identify: identify::Behaviour,
}

/// Events generated by the P2P network
#[derive(Debug)]
pub enum P2PEvent {
    /// New peer connected
    PeerConnected(PeerId),
    /// Peer disconnected  
    PeerDisconnected(PeerId),
    /// Message received from gossipsub
    GossipMessage {
        peer_id: PeerId,
        topic: String,
        message: NetworkMessage,
    },
    /// Request received from a peer
    RequestReceived {
        peer_id: PeerId,
        request: NetworkMessage,
    },
    /// Response received from a peer
    ResponseReceived {
        peer_id: PeerId,
        response: NetworkMessage,
    },
    /// Network error occurred
    NetworkError(String),
    /// New peer discovered via mDNS
    PeerDiscovered(PeerId),
}

/// Real P2P Node Implementation with libp2p
pub struct P2PNode {
    swarm: Swarm<P2PBehaviour>,
    config: P2PConfig,
    blockchain: Option<Blockchain>,
    local_peer_id: PeerId,
}

impl P2PNode {
    /// Create a new P2P node
    pub async fn new(config: P2PConfig) -> Result<Self> {
        // Create a random PeerId for this node
        let local_key = libp2p::identity::Keypair::generate_ed25519();
        let local_peer_id = PeerId::from(local_key.public());

        info!("üÜî Local Peer ID: {}", local_peer_id);

        // Set up the swarm with TCP transport, Noise encryption, and Yamux multiplexing
        let swarm = SwarmBuilder::with_existing_identity(local_key)
            .with_tokio()
            .with_tcp(
                tcp::Config::default(),
                noise::Config::new,
                yamux::Config::default,
            )?
            .with_behaviour(|key| {
                // Gossipsub configuration
                let gossipsub_config = gossipsub::ConfigBuilder::default()
                    .heartbeat_interval(Duration::from_secs(10))
                    .validation_mode(gossipsub::ValidationMode::Strict)
                    .message_id_fn(message_id_fn)
                    .build()
                    .expect("Valid config");

                let mut gossipsub = gossipsub::Behaviour::new(
                    gossipsub::MessageAuthenticity::Signed(key.clone()),
                    gossipsub_config,
                )?;

                // Subscribe to blockchain topics
                gossipsub.subscribe(&gossipsub::IdentTopic::new(BLOCKCHAIN_TOPIC))?;
                gossipsub.subscribe(&gossipsub::IdentTopic::new(TRANSACTION_TOPIC))?;

                // mDNS for local discovery
                let mdns = if config.enable_mdns {
                    mdns::tokio::Behaviour::new(mdns::Config::default(), key.public().to_peer_id())?
                } else {
                    return Err(Box::new(std::io::Error::new(
                        std::io::ErrorKind::Other,
                        "mDNS disabled",
                    )));
                };

                // Identify protocol for node information exchange
                let identify = identify::Behaviour::new(identify::Config::new(
                    "/aevum-bond/1.0.0".to_string(),
                    key.public(),
                ));

                Ok(P2PBehaviour {
                    gossipsub,
                    mdns,
                    identify,
                })
            })?
            .with_swarm_config(|c| c.with_idle_connection_timeout(Duration::from_secs(60)))
            .build();

        Ok(Self {
            swarm,
            config,
            blockchain: None,
            local_peer_id,
        })
    }

    /// Start the P2P node
    pub async fn start(&mut self) -> Result<()> {
        // Determine listening address
        let listen_addr = if self.config.port == 0 {
            format!("/ip4/{}/tcp/0", self.config.listen_addr).parse()?
        } else {
            format!("/ip4/{}/tcp/{}", self.config.listen_addr, self.config.port).parse()?
        };

        // Start listening
        self.swarm.listen_on(listen_addr)?;
        info!("üéß P2P node listening on {}", self.config.listen_addr);

        Ok(())
    }

    /// Run the event loop
    pub async fn run(&mut self) -> Result<()> {
        info!("üöÄ Starting P2P node event loop");

        loop {
            select! {
                event = self.swarm.select_next_some() => {
                    if let Err(e) = self.handle_swarm_event(event).await {
                        error!("Error handling swarm event: {}", e);
                    }
                }
                _ = tokio::signal::ctrl_c() => {
                    info!("üõë Received shutdown signal, stopping node");
                    break;
                }
            }
        }

        Ok(())
    }

    /// Handle swarm events
    async fn handle_swarm_event(&mut self, event: SwarmEvent<P2PBehaviourEvent>) -> Result<()> {
        match event {
            SwarmEvent::NewListenAddr { address, .. } => {
                info!("üéß Listening on {}", address);
            }
            SwarmEvent::Behaviour(P2PBehaviourEvent::Mdns(mdns::Event::Discovered(list))) => {
                for (peer_id, _multiaddr) in list {
                    info!("üîç Discovered peer via mDNS: {}", peer_id);
                    self.swarm
                        .behaviour_mut()
                        .gossipsub
                        .add_explicit_peer(&peer_id);
                }
            }
            SwarmEvent::Behaviour(P2PBehaviourEvent::Mdns(mdns::Event::Expired(list))) => {
                for (peer_id, _multiaddr) in list {
                    info!("‚è∞ mDNS peer expired: {}", peer_id);
                    self.swarm
                        .behaviour_mut()
                        .gossipsub
                        .remove_explicit_peer(&peer_id);
                }
            }
            SwarmEvent::Behaviour(P2PBehaviourEvent::Gossipsub(gossipsub::Event::Message {
                propagation_source: _,
                message_id: _,
                message,
            })) => {
                self.handle_gossip_message(message).await?;
            }
            SwarmEvent::ConnectionEstablished {
                peer_id, endpoint, ..
            } => {
                info!("ü§ù Connection established with {}: {:?}", peer_id, endpoint);
            }
            SwarmEvent::ConnectionClosed { peer_id, cause, .. } => {
                info!("üîö Connection closed with {}: {:?}", peer_id, cause);
            }
            _ => {}
        }

        Ok(())
    }

    /// Handle gossipsub messages
    async fn handle_gossip_message(&mut self, message: gossipsub::Message) -> Result<()> {
        let topic = message.topic.as_str();

        match serde_json::from_slice::<NetworkMessage>(&message.data) {
            Ok(network_msg) => {
                debug!(
                    "üì® Received gossip message on topic '{}': {:?}",
                    topic, network_msg
                );
                self.process_network_message(network_msg, message.source)
                    .await?;
            }
            Err(e) => {
                warn!("‚ùå Failed to decode gossip message: {}", e);
            }
        }

        Ok(())
    }

    /// Process network messages
    async fn process_network_message(
        &mut self,
        message: NetworkMessage,
        source: Option<PeerId>,
    ) -> Result<()> {
        match message {
            NetworkMessage::BlockBroadcast(block) => {
                info!("üì¶ Received block broadcast: {}", block.hash());
                // TODO: Validate and add block to blockchain
            }
            NetworkMessage::TransactionBroadcast(transaction) => {
                info!("üí∏ Received transaction broadcast: {}", transaction.hash());
                // TODO: Add transaction to mempool
            }
            NetworkMessage::Ping { node_id, timestamp } => {
                if let Some(peer_id) = source {
                    info!("üèì Ping from {} ({})", node_id, timestamp);
                    // Send pong response
                    let pong = NetworkMessage::Pong {
                        node_id: self.local_peer_id.to_string(),
                        timestamp: std::time::SystemTime::now()
                            .duration_since(std::time::UNIX_EPOCH)
                            .unwrap()
                            .as_secs(),
                    };
                    self.broadcast_message(pong).await?;
                }
            }
            NetworkMessage::SyncRequest { chain_height } => {
                info!("üîÑ Sync request for height {}", chain_height);
                // TODO: Handle sync request
            }
            _ => {
                debug!("üì§ Processed message: {:?}", message);
            }
        }

        Ok(())
    }

    /// Broadcast a message to all peers
    pub async fn broadcast_message(&mut self, message: NetworkMessage) -> Result<()> {
        let topic = match message {
            NetworkMessage::BlockBroadcast(_)
            | NetworkMessage::SyncRequest { .. }
            | NetworkMessage::SyncResponse { .. } => BLOCKCHAIN_TOPIC,
            NetworkMessage::TransactionBroadcast(_) => TRANSACTION_TOPIC,
            _ => BLOCKCHAIN_TOPIC,
        };

        let data = serde_json::to_vec(&message)?;

        if let Err(e) = self
            .swarm
            .behaviour_mut()
            .gossipsub
            .publish(gossipsub::IdentTopic::new(topic), data)
        {
            error!("‚ùå Failed to publish message: {}", e);
            return Err(BlockchainError::Network(format!(
                "Failed to publish message: {}",
                e
            )));
        }

        debug!("üì° Broadcast message on topic '{}': {:?}", topic, message);
        Ok(())
    }

    /// Get the local peer ID
    pub fn local_peer_id(&self) -> &PeerId {
        &self.local_peer_id
    }

    /// Get node ID as string
    pub fn node_id(&self) -> String {
        self.local_peer_id.to_string()
    }

    /// Set blockchain reference
    pub fn set_blockchain(&mut self, blockchain: Blockchain) {
        self.blockchain = Some(blockchain);
    }

    /// Get connected peers count
    pub fn connected_peers(&self) -> usize {
        self.swarm.network_info().num_peers()
    }

    /// Get network info
    pub fn network_status(&self) -> NetworkStatus {
        NetworkStatus {
            is_running: true,
            node_id: self.local_peer_id.to_string(),
            peer_count: self.connected_peers(),
        }
    }
}

/// Message ID function for gossipsub
fn message_id_fn(message: &gossipsub::Message) -> gossipsub::MessageId {
    let mut s = DefaultHasher::new();
    message.data.hash(&mut s);
    gossipsub::MessageId::from(s.finish().to_string())
}

/// Network status information
#[derive(Debug, Serialize, Deserialize)]
pub struct NetworkStatus {
    pub is_running: bool,
    pub node_id: String,
    pub peer_count: usize,
}
